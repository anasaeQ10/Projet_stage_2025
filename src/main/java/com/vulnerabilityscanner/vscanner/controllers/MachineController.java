package com.vulnerabilityscanner.vscanner.controllers;

import com.vulnerabilityscanner.vscanner.entities.Machine;
import com.vulnerabilityscanner.vscanner.entities.MachineArchive;
import com.vulnerabilityscanner.vscanner.repositories.MachineArchiveRepository;
import com.vulnerabilityscanner.vscanner.services.MachineExcelExportService;
import com.vulnerabilityscanner.vscanner.services.MachineService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;

@Controller
@RequestMapping("/machines")
public class MachineController {

    @Autowired
    private MachineService machineService;
    @Autowired
    private MachineArchiveRepository machineArchiveRepository;
    @Autowired
    private MachineExcelExportService machineExcelExportService;

    @GetMapping
    public String listMachines(Model model) {
        model.addAttribute("machines", machineService.findAll());
        return "machines/list";
    }

    @GetMapping("/add")
    public String showAddForm(Model model) {
        model.addAttribute("machine", new Machine());
        return "machines/add";
    }

    @PostMapping("/add")
    public String addMachine(@Valid @ModelAttribute Machine machine, BindingResult result) {
        if (result.hasErrors()) {
            return "machines/add";
        }
        machineService.save(machine);
        return "redirect:/machines";
    }

    @GetMapping("/{id}")
    public String showDetails(@PathVariable Long id, Model model) {
        Optional<Machine> machineOpt = machineService.findById(id);
        if (machineOpt.isEmpty()) {
            return "redirect:/machines";
        }
        model.addAttribute("machine", machineOpt.get());
        return "machines/details";
    }

    @GetMapping("/edit/{id}")
    public String showEditForm(@PathVariable Long id, Model model) {
        Optional<Machine> machineOpt = machineService.findById(id);
        if (machineOpt.isEmpty()) {
            return "redirect:/machines";
        }
        model.addAttribute("machine", machineOpt.get());
        return "machines/edit";
    }

    @PostMapping("/edit/{id}")
    public String editMachine(@PathVariable Long id, @Valid @ModelAttribute Machine machine, BindingResult result) {
        if (result.hasErrors()) {
            return "machines/edit";
        }
        machine.setId(id);
        machineService.save(machine);
        return "redirect:/machines";
    }

    @GetMapping("/delete/{id}")
    public String deleteMachine(@PathVariable Long id) {
        machineService.deleteById(id);
        return "redirect:/machines";
    }

    @GetMapping("/machines/export")
    public ResponseEntity<byte[]> exportMachinesReport() {
        try {
            List<Machine> activeMachines = machineService.findAll();
            List<MachineArchive> archivedMachines = machineArchiveRepository.findAll();

            byte[] excelContent = machineExcelExportService.generateMachinesReport(activeMachines, archivedMachines);

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
            headers.setContentDispositionFormData(
                    "attachment",
                    "rapport_machines_" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")) + ".xlsx"
            );

            return ResponseEntity.ok()
                    .headers(headers)
                    .body(excelContent);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.internalServerError().build();
        }
    }
}
