package com.vulnerabilityscanner.vscanner.services;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.vulnerabilityscanner.vscanner.dto.NvdResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.StreamSupport;
import java.util.Comparator;

@Service
public class NvdService {

    private final RestTemplate restTemplate;

    @Autowired
    public NvdService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public List<NvdResponse.CveItem> searchCveItemsByKeyword(String keyword) {
        ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);
        ZonedDateTime sevenDaysAgo = now.minusDays(60);

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssXXX");

        String pubStartDate = sevenDaysAgo.format(formatter);
        String pubEndDate = now.format(formatter);

        HttpHeaders headers = new HttpHeaders();
        headers.set("User-Agent", "SpringBoot-App");
        HttpEntity<Void> requestEntity = new HttpEntity<>(headers);

        List<NvdResponse.CveItem> allItems = new ArrayList<>();
        int resultsPerPage = 200;  // max autorisé
        int startIndex = 0;
        int totalResults = Integer.MAX_VALUE; // valeur initiale élevée

        ObjectMapper mapper = new ObjectMapper();

        while (startIndex < totalResults) {
            String url = "https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch="
                    + keyword
                    + "&resultsPerPage=" + resultsPerPage
                    + "&startIndex=" + startIndex
                    + "&pubStartDate=" + pubStartDate
                    + "&pubEndDate=" + pubEndDate;

            ResponseEntity<String> response = restTemplate.exchange(
                    url,
                    HttpMethod.GET,
                    requestEntity,
                    String.class
            );

            try {
                JsonNode root = mapper.readTree(response.getBody());

                totalResults = root.path("totalResults").asInt();  // total vulnérabilités trouvées
                JsonNode vulns = root.path("vulnerabilities");

                if (!vulns.isArray() || vulns.size() == 0) {
                    break;  // plus de données à récupérer
                }

                for (JsonNode vulnNode : vulns) {
                    JsonNode cveNode = vulnNode.path("cve");

                    NvdResponse.CveItem item = new NvdResponse.CveItem();
                    item.setId(cveNode.path("id").asText());
                    item.setSourceIdentifier(cveNode.path("sourceIdentifier").asText());
                    item.setPublished(cveNode.path("published").asText());
                    item.setLastModified(cveNode.path("lastModified").asText());
                    item.setVulnStatus(cveNode.path("vulnStatus").asText());

                    item.setEnglishDescription(
                            StreamSupport.stream(cveNode.path("descriptions").spliterator(), false)
                                    .filter(desc -> "en".equals(desc.path("lang").asText()))
                                    .map(desc -> desc.path("value").asText())
                                    .findFirst()
                                    .orElse("Pas de description.")
                    );

                    // Extraction CVSS
                    NvdResponse.CveItem.CvssData cvssData = new NvdResponse.CveItem.CvssData();
                    JsonNode metrics = cveNode.path("metrics");
                    JsonNode cvssNode = null;
                    JsonNode metricNode = null;

                    String[] versions = {"cvssMetricV40", "cvssMetricV31", "cvssMetricV30", "cvssMetricV2"};
                    String foundVersion = null;

                    for (String ver : versions) {
                        JsonNode arr = metrics.path(ver);
                        if (arr.isArray() && arr.size() > 0) {
                            metricNode = arr.get(0);
                            cvssNode = metricNode.path("cvssData");
                            foundVersion = ver;
                            break;
                        }
                    }

                    if (cvssNode != null && !cvssNode.isMissingNode()) {
                        switch (foundVersion) {
                            case "cvssMetricV40": cvssData.setVersion("4.0"); break;
                            case "cvssMetricV31": cvssData.setVersion("3.1"); break;
                            case "cvssMetricV30": cvssData.setVersion("3.0"); break;
                            default: cvssData.setVersion("2.0"); break;
                        }

                        cvssData.setBaseScore(cvssNode.path("baseScore").asDouble(0.0));
                        cvssData.setVectorString(cvssNode.path("vectorString").asText(""));

                        String severity = cvssNode.path("baseSeverity").asText("");
                        if (severity.isEmpty()) {
                            severity = metricNode.path("baseSeverity").asText("");
                        }
                        if (severity == null || severity.isEmpty()) {
                            cvssData.setSeverity("N/A");
                        } else {
                            cvssData.setSeverity(severity.toUpperCase());
                        }

                        item.setCvss(cvssData);
                    } else {
                        cvssData.setVersion("N/A");
                        cvssData.setSeverity("N/A");
                        item.setCvss(cvssData);
                    }

                    allItems.add(item);
                }

                startIndex += resultsPerPage;

            } catch (Exception e) {
                e.printStackTrace();
                break;
            }
        }

        // Tri décroissant sur la date publiée (plus récent en premier)
        allItems.sort(Comparator.comparing(NvdResponse.CveItem::getPublished).reversed());

        return allItems;
    }
}
