package com.vulnerabilityscanner.vscanner.services;

import com.vulnerabilityscanner.vscanner.entities.Machine;
import com.vulnerabilityscanner.vscanner.entities.User;
import com.vulnerabilityscanner.vscanner.entities.CveDetailEntity;
import com.vulnerabilityscanner.vscanner.repositories.MachineRepository;
import com.vulnerabilityscanner.vscanner.repositories.UserRepository;
import com.vulnerabilityscanner.vscanner.repositories.CveDetailRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;
import java.time.format.TextStyle;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class StatisticsService {

    @Autowired
    private MachineRepository machineRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private CveDetailRepository cveDetailRepository;

    @Autowired
    private MachineService machineService;

    // Méthodes pour les statistiques machines
    public long getTotalMachines() {
        return machineRepository.count();
    }

    public long getVulnerableMachinesCount() {
        return machineRepository.countByCveScoreGreaterThanEqual(4.0);
    }

    public double getVulnerablePercentage() {
        long total = getTotalMachines();
        if (total == 0) return 0.0;
        return Math.round((getVulnerableMachinesCount() * 100.0 / total) * 10.0) / 10.0;
    }

    public double getAvgCveScore() {
        Double avg = machineRepository.getAverageCveScore();
        return avg != null ? Math.round(avg * 10.0) / 10.0 : 0.0;
    }

    public Map<String, Long> getMachinesByType() {
        List<Machine> machines = machineRepository.findAll();
        return machines.stream()
                .collect(Collectors.groupingBy(Machine::getType, Collectors.counting()));
    }

    public Map<String, Long> getSeverityDistribution() {
        List<Machine> machines = machineRepository.findAll();
        Map<String, Long> distribution = new LinkedHashMap<>();
        distribution.put("Securisé", machines.stream().filter(m -> m.getCveScore() < 4).count());
        distribution.put("À vérifier", machines.stream().filter(m -> m.getCveScore() >= 4 && m.getCveScore() < 7).count());
        distribution.put("Vérifier", machines.stream().filter(m -> m.getCveScore() >= 7 && m.getCveScore() < 9).count());
        distribution.put("Très dangereux", machines.stream().filter(m -> m.getCveScore() >= 9).count());
        return distribution;
    }

    public List<String> getMachineTypes() {
        return machineRepository.findDistinctTypes();
    }

    public List<Machine> getAllMachines() {
        return machineRepository.findAll();
    }

    // Méthodes pour les statistiques utilisateurs
    public long getTotalUsers() {
        return userRepository.count();
    }

    public long getAdminsCount() {
        return userRepository.countByRole("ROLE_ADMIN");
    }

    public long getNormalUsersCount() {
        return userRepository.countByRole("ROLE_USER");
    }

    public Map<String, Long> getUsersByMonth() {
        List<User> users = userRepository.findAll();
        Map<String, Long> usersByMonth = new LinkedHashMap<>();

        // Initialiser tous les mois avec 0
        for (int i = 1; i <= 12; i++) {
            String monthName = Month.of(i).getDisplayName(TextStyle.SHORT, Locale.FRENCH);
            usersByMonth.put(monthName, 0L);
        }

        // Compter les utilisateurs par mois de création
        users.forEach(user -> {
            if (user.getDateCreation() != null) {
                int monthValue = user.getDateCreation().getMonthValue();
                String monthName = Month.of(monthValue).getDisplayName(TextStyle.SHORT, Locale.FRENCH);
                usersByMonth.put(monthName, usersByMonth.get(monthName) + 1);
            }
        });

        return usersByMonth;
    }

    public List<User> getRecentUsers() {
        return userRepository.findTop5ByOrderByDateCreationDesc();
    }

    // Méthodes pour les statistiques de vulnérabilités
    public long getTotalVulnerabilities() {
        return cveDetailRepository.count();
    }

    // Correction possible
    public Map<String, Long> getVulnerabilitiesByMonth() {
        List<CveDetailEntity> vulnerabilities = cveDetailRepository.findAll();
        Map<String, Long> vulnsByMonth = new LinkedHashMap<>();

        // Initialiser tous les mois avec 0
        for (int i = 1; i <= 12; i++) {
            String monthName = Month.of(i).getDisplayName(TextStyle.SHORT, Locale.FRENCH);
            vulnsByMonth.put(monthName, 0L);
        }

        // Si vous n'avez pas de date dans CveDetailEntity, vous devriez en ajouter une
        // Pour l'instant, on répartit aléatoirement pour la démo
        Random random = new Random();
        vulnerabilities.forEach(vuln -> {
            int monthValue = random.nextInt(12) + 1;
            String monthName = Month.of(monthValue).getDisplayName(TextStyle.SHORT, Locale.FRENCH);
            vulnsByMonth.put(monthName, vulnsByMonth.get(monthName) + 1);
        });

        return vulnsByMonth;
    }

    public List<CveDetailEntity> getRecentVulnerabilities() {
        return cveDetailRepository.findTop10ByOrderByIdDesc();
    }

    // Méthode pour calculer la croissance des machines (pourcentage)
    public double getMachineGrowth() {
        LocalDate now = LocalDate.now();
        LocalDate lastMonth = now.minusMonths(1);

        long currentMonthCount = machineRepository.countByCreatedDateAfter(now.withDayOfMonth(1).atStartOfDay());
        long lastMonthCount = machineRepository.countByCreatedDateBetween(
                lastMonth.withDayOfMonth(1).atStartOfDay(),
                lastMonth.withDayOfMonth(lastMonth.lengthOfMonth()).atTime(23, 59, 59));

        if (lastMonthCount == 0) return 0.0;
        return Math.round(((currentMonthCount - lastMonthCount) * 100.0 / lastMonthCount) * 10.0) / 10.0;
    }

    // Méthode pour obtenir toutes les données du tableau de bord
    public Map<String, Object> getDashboardData() {
        Map<String, Object> data = new HashMap<>();


        // Données machines
        data.put("totalMachines", getTotalMachines());
        data.put("vulnerableMachinesCount", getVulnerableMachinesCount());
        data.put("vulnerablePercentage", getVulnerablePercentage());
        data.put("avgCveScore", getAvgCveScore());
        data.put("machinesByType", getMachinesByType());
        data.put("severityDistribution", getSeverityDistribution());
        data.put("machineTypes", getMachineTypes());
        data.put("machines", getAllMachines());
        data.put("machineGrowth", getMachineGrowth());

        // Données utilisateurs
        data.put("totalUsers", getTotalUsers());
        data.put("adminsCount", getAdminsCount());
        data.put("normalUsersCount", getNormalUsersCount());
        data.put("usersByMonth", getUsersByMonth());
        data.put("recentUsers", getRecentUsers());

        // Données vulnérabilités
        data.put("totalVulnerabilities", getTotalVulnerabilities());
        data.put("vulnerabilitiesByMonth", getVulnerabilitiesByMonth());
        data.put("recentVulnerabilities", getRecentVulnerabilities());

        return data;
    }

}