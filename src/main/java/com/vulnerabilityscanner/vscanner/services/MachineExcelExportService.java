package com.vulnerabilityscanner.vscanner.services;

import com.vulnerabilityscanner.vscanner.entities.Machine;
import com.vulnerabilityscanner.vscanner.entities.MachineArchive;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Service
public class MachineExcelExportService {

    private static final int MAX_FILE_SIZE_MB = 10;
    private static final int MAX_ROWS = 100_000;
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final DateTimeFormatter SHEET_DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss");

    public byte[] generateMachinesReport(List<Machine> activeMachines, List<MachineArchive> archivedMachines) throws IOException {
        validateInput(activeMachines, archivedMachines);

        try (Workbook workbook = new XSSFWorkbook()) {
            createMetadataSheet(workbook, activeMachines.size(), archivedMachines.size());

            CellStyle headerStyle = createHeaderStyle(workbook);
            createActiveMachinesSheet(workbook, headerStyle, activeMachines);
            createArchivedMachinesSheet(workbook, headerStyle, archivedMachines);

            return writeToByteArray(workbook);
        }
    }

    private void validateInput(List<Machine> active, List<MachineArchive> archived) {
        if (active == null || archived == null) {
            throw new IllegalArgumentException("Les listes de machines ne peuvent pas être null");
        }
        if (active.size() + archived.size() > MAX_ROWS) {
            throw new IllegalArgumentException(String.format("Trop de données à exporter (max %d lignes)", MAX_ROWS));
        }
    }

    private void createMetadataSheet(Workbook workbook, int activeCount, int archivedCount) {
        Sheet metaSheet = workbook.createSheet("Métadonnées");

        CellStyle titleStyle = workbook.createCellStyle();
        Font titleFont = workbook.createFont();
        titleFont.setBold(true);
        titleFont.setFontHeightInPoints((short)14);
        titleStyle.setFont(titleFont);
        titleStyle.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
        titleStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);

        CellStyle valueStyle = workbook.createCellStyle();
        Font valueFont = workbook.createFont();
        valueFont.setFontHeightInPoints((short)12);
        valueStyle.setFont(valueFont);

        Object[][] metadata = {
                {"Titre du rapport", "Rapport des machines"},
                {"Date d'exportation", LocalDateTime.now().format(DATE_FORMATTER)},
                {"Exporté par", getCurrentUsername()},
                {"Nombre de machines actives", activeCount},
                {"Nombre de machines archivées", archivedCount},
                {"Total", activeCount + archivedCount}
        };

        for (int i = 0; i < metadata.length; i++) {
            Row row = metaSheet.createRow(i);
            Cell titleCell = row.createCell(0);
            titleCell.setCellValue(metadata[i][0].toString());
            titleCell.setCellStyle(titleStyle);

            Cell valueCell = row.createCell(1);
            Object value = metadata[i][1];
            if (value instanceof Number) {
                valueCell.setCellValue(((Number) value).doubleValue());
            } else {
                valueCell.setCellValue(value.toString());
            }
            valueCell.setCellStyle(valueStyle);
        }

        metaSheet.autoSizeColumn(0);
        metaSheet.autoSizeColumn(1);
    }

    private String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication != null ? authentication.getName() : "Système";
    }

    private CellStyle createHeaderStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        Font font = workbook.createFont();
        font.setBold(true);
        style.setFont(font);
        style.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
        style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
        style.setBorderBottom(BorderStyle.THIN);
        style.setBorderTop(BorderStyle.THIN);
        style.setBorderLeft(BorderStyle.THIN);
        style.setBorderRight(BorderStyle.THIN);
        return style;
    }

    private void createActiveMachinesSheet(Workbook workbook, CellStyle headerStyle, List<Machine> machines) {
        String sheetName = "Actives_" + LocalDateTime.now().format(SHEET_DATE_FORMATTER);
        Sheet sheet = workbook.createSheet(sheetName);

        String[] headers = {
                "ID", "Nom", "Type", "Constructeur", "Modèle", "N° Série",
                "Adresse IP", "Adresse MAC", "OS", "CPU", "RAM (Go)",
                "Stockage (Go)", "Date Achat", "Garantie Expire", "Localisation", "Description"
        };

        createSheetHeader(sheet, headerStyle, headers);
        int rowNum = 1;
        for (Machine m : machines) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(m.getId());
            row.createCell(1).setCellValue(getSafeString(m.getName()));
            row.createCell(2).setCellValue(getSafeString(m.getType()));
            row.createCell(3).setCellValue(getSafeString(m.getManufacturer()));
            row.createCell(4).setCellValue(getSafeString(m.getModel()));
            row.createCell(5).setCellValue(getSafeString(m.getSerialNumber()));
            row.createCell(6).setCellValue(getSafeString(m.getIpAddress()));
            row.createCell(7).setCellValue(getSafeString(m.getMacAddress()));
            row.createCell(8).setCellValue(getSafeString(m.getOperatingSystem()));
            row.createCell(9).setCellValue(getSafeString(m.getCpu()));
            row.createCell(10).setCellValue(m.getRamGb());
            row.createCell(11).setCellValue(m.getStorageGb());
            row.createCell(12).setCellValue(formatDate(m.getPurchaseDate()));
            row.createCell(13).setCellValue(formatDate(m.getWarrantyExpiryDate()));
            row.createCell(14).setCellValue(getSafeString(m.getLocation()));
            row.createCell(15).setCellValue(getSafeString(m.getDescription()));
        }

        autoSizeColumns(sheet, headers.length);
    }

    private void createArchivedMachinesSheet(Workbook workbook, CellStyle headerStyle, List<MachineArchive> machines) {
        String sheetName = "Archives_" + LocalDateTime.now().format(SHEET_DATE_FORMATTER);
        Sheet sheet = workbook.createSheet(sheetName);

        String[] headers = {
                "ID Machine", "Nom", "Type", "Constructeur", "Modèle", "N° Série",
                "Adresse IP", "Adresse MAC", "OS", "CPU", "RAM (Go)",
                "Stockage (Go)", "Date Achat", "Garantie Expire", "Localisation",
                "Description", "Date Archivage", "Type Action"
        };

        createSheetHeader(sheet, headerStyle, headers);
        int rowNum = 1;
        for (MachineArchive m : machines) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(m.getMachineId());
            row.createCell(1).setCellValue(getSafeString(m.getName()));
            row.createCell(2).setCellValue(getSafeString(m.getType()));
            row.createCell(3).setCellValue(getSafeString(m.getManufacturer()));
            row.createCell(4).setCellValue(getSafeString(m.getModel()));
            row.createCell(5).setCellValue(getSafeString(m.getSerialNumber()));
            row.createCell(6).setCellValue(getSafeString(m.getIpAddress()));
            row.createCell(7).setCellValue(getSafeString(m.getMacAddress()));
            row.createCell(8).setCellValue(getSafeString(m.getOperatingSystem()));
            row.createCell(9).setCellValue(getSafeString(m.getCpu()));
            row.createCell(10).setCellValue(m.getRamGb());
            row.createCell(11).setCellValue(m.getStorageGb());
            row.createCell(12).setCellValue(formatDate(m.getPurchaseDate()));
            row.createCell(13).setCellValue(formatDate(m.getWarrantyExpiryDate()));
            row.createCell(14).setCellValue(getSafeString(m.getLocation()));
            row.createCell(15).setCellValue(getSafeString(m.getDescription()));
            row.createCell(16).setCellValue(formatDate(m.getArchivedAt()));
            row.createCell(17).setCellValue(getSafeString(m.getActionType()));
        }

        autoSizeColumns(sheet, headers.length);
    }

    private void createSheetHeader(Sheet sheet, CellStyle headerStyle, String[] headers) {
        Row headerRow = sheet.createRow(0);
        for (int i = 0; i < headers.length; i++) {
            Cell cell = headerRow.createCell(i);
            cell.setCellValue(headers[i]);
            cell.setCellStyle(headerStyle);
        }
    }

    private String getSafeString(String value) {
        return value != null ? value : "";
    }

    private String formatDate(Object date) {
        if (date == null) return "";
        if (date instanceof LocalDateTime) {
            return ((LocalDateTime) date).format(DATE_FORMATTER);
        } else if (date instanceof LocalDate) {
            return ((LocalDate) date).atStartOfDay().format(DATE_FORMATTER);
        }
        return date.toString();
    }

    private void autoSizeColumns(Sheet sheet, int columnCount) {
        for (int i = 0; i < columnCount; i++) {
            sheet.autoSizeColumn(i);
        }
    }

    private byte[] writeToByteArray(Workbook workbook) throws IOException {
        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            workbook.write(outputStream);
            if (outputStream.size() > MAX_FILE_SIZE_MB * 1024 * 1024) {
                throw new IOException(String.format("Le fichier excède la taille maximale de %dMB", MAX_FILE_SIZE_MB));
            }
            return outputStream.toByteArray();
        }
    }
}
